// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  //directUrl = env("DIRECT_URL")
}

// -------------------------------------
// Enum Definitions
// -------------------------------------

// Status for verifiable documents.
enum DocumentStatus {
  Pending
  InReview
  Approved
  Declined
  Abandoned

  @@map("document_status")
}

// Type of user address.
enum UserAddressType {
  billing
  shipping
  home
  office

  @@map("user_address_type")
}

// Status for quotations.
enum QuotationStatus {
  pending
  accepted
  rejected
  cancelled
  not_selected  // Cuando el cliente eligió otra cotización

  @@map("quotation_status")
}

// Status for counter offers.
enum CounterOfferStatus {
  pending
  accepted
  rejected
  cancelled
  
  @@map("counter_offer_status")
}

// Status for service appointments.
enum AppointmentStatus {
  awaiting_acceptance  // Cotización creada, esperando que cliente acepte
  pending              // Cliente aceptó, esperando que aliado confirme "En Camino"
  confirmed            // Aliado confirmó que va en camino
  completed
  cancelled
  in_progress
  rescheduled

  @@map("order_status")
}

// Status for service requests.
enum ServiceRequestStatus {
  receiving_offers
  receiving_applications
  offer_accepted
  cancelled
  completed

  @@map("service_request_status")
}

// Type of service request
enum RequestType {
  quotation_based  // Flujo actual con cotizaciones
  fixed_price      // Nuevo flujo con precio fijo

  @@map("request_type")
}

// Status for applications (fixed price services)
enum ApplicationStatus {
  pending   // Aplicación enviada, esperando selección del cliente
  selected  // Cliente seleccionó este aliado
  rejected  // Cliente no seleccionó este aliado (automático al seleccionar otro)

  @@map("application_status")
}

// Service type for commission settings
enum CommissionServiceType {
  quotation_based  // Para servicios con cotización
  fixed_price      // Para servicios de precio fijo

  @@map("commission_service_type")
}

// Modality of a service appointment.
enum Modality {
  remote
  in_person
  hybrid

  @@map("modality_type")
}

// Value type for category-specific parameters.
enum CategoryParameterValueType {
  text
  number
  boolean
  select

  @@map("category_parameter_type")
}

// Type of pricing for certain services.
enum PricingType {
  per_hour
  per_day
  per_job

  @@map("pricing_type")
}

enum AvailabilityType {
  immediate
  next_day
  in_days

  @@map("availability_type")
}

// Describe el tipo de movimiento en una billetera.
enum WalletTransactionType {
  payment_received // Pago de un cliente por un servicio completado.
  withdrawal       // Retiro de fondos del profesional a su banco.
  refund           // Reembolso procesado.
  top_up           // Recarga de saldo hecha por el profesional.
  adjustment       // Ajuste manual hecho por un administrador.

  @@map("wallet_transaction_type")
}

// Estado de una transacción de billetera.
enum TransactionStatus {
  pending
  completed
  failed
  cancelled

  @@map("transaction_status")
}

// Género del usuario.
enum Gender {
  male
  female
  other
  prefer_not_to_say

  @@map("gender")
}

// Canal de verificación de documentos.
enum VerificationChannel {
  didit
  manual

  @@map("verification_channel")
}

// Estado de pago de comisiones.
enum CommissionPaymentStatus {
  pending
  partial_paid
  fully_paid
  overdue
  waived
  
  @@map("commission_payment_status")
}

// Tipo de incidente en una cita.
enum IncidentType {
  accident
  emergency
  delay
  inconsistency
  other

  @@map("incident_type")
}

// Severidad de un incidente.
enum IncidentSeverity {
  low
  medium
  high
  critical

  @@map("incident_severity")
}

// -------------------------------------
// Models
// -------------------------------------

model Role {
  id          Int @id @default(autoincrement())
  name        String @unique
  users       User[]
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@map("roles")
}

model DocumentType {
  id                  Int @id @default(autoincrement())
  name                String @unique
  description         String?
  verifiable_documents VerifiableDocument[]
  created_at          DateTime @default(now()) 
  updated_at          DateTime @updatedAt

  @@map("document_types")
}

model User {
  id                        String @id @db.Uuid
  role_id                   Int
  name                      String?
  lastname                  String?
  phone_number              String @unique
  email                     String?
  gender                    Gender?
  password_hash             String?
  username                  String? @unique
  is_active                 Boolean @default(false)
  is_online                 Boolean @default(false)
  last_login                DateTime?
  photo_url                 String?
  created_at                DateTime @default(now())
  updated_at                DateTime @updatedAt

  role                      Role @relation(fields: [role_id], references: [id])
  addresses                 UserAddress[]
  verification              UserVerification?
  refresh_tokens            RefreshToken[]
  verifiable_documents      VerifiableDocument[]
  client_appointments       ServiceAppointment[] @relation("ClientAppointments")
  professional_appointments ServiceAppointment[] @relation("ProfessionalAppointments")
  reviews_given             Review[] @relation("ReviewerReviews")
  service_requests          ServiceRequest[]
  quotations                Quotations[]
  counter_offers            CounterOffer[]
  intrabbler_profile        IntrabblerProfile?
  wallet                    Wallet?
  commission_payments_processed CommissionPayment[] @relation("CommissionProcessor")
  incidents_reported        AppointmentIncident[] @relation("IncidentReporter")
  incidents_resolved        AppointmentIncident[] @relation("IncidentResolver")
  
  // Nuevas relaciones para fixed price services
  applications              Applications[]
  ally_availability         AllyAvailability[]
  device_tokens            DeviceToken[]
  failed_notifications     FailedNotification[]

  @@map("users")
}

model RefreshToken {
  id          Int @id @default(autoincrement())
  user_id     String @db.Uuid   
  token       String @unique
  expires_at  DateTime  
  created_at  DateTime @default(now()) 
  updated_at  DateTime @updatedAt
  revoked_at  DateTime?

  user User @relation(fields: [user_id], references: [id])

  @@map("refresh_tokens")
}

model UserAddress {
  id          Int @id @default(autoincrement())
  user_id     String @db.Uuid             
  address     String
  city        String @default("Valledupar")
  state       String @default("Cesar")
  postal_code String?          
  country     String @default("Colombia")
  type        UserAddressType @default(home)
  is_primary  Boolean @default(false)
  latitude    Float?
  longitude   Float?
  label       String?
  reference   String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id])
  service_requests ServiceRequest[]
  service_appointments ServiceAppointment[] @relation("LocationAddress")

  @@map("user_addresses")
}

model UserVerification {
  id                     Int @id @default(autoincrement())
  user_id                String @db.Uuid @unique
  phone_verified         Boolean @default(false)
  email_verified         Boolean @default(false)
  phone_verified_at      DateTime? 
  email_verified_at      DateTime? 
  last_verification_sent DateTime?
  created_at             DateTime @default(now()) 
  updated_at             DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id])

  @@map("user_verifications")
}

model IntrabblerProfile {
  id            Int @id @default(autoincrement())
  user_id       String @db.Uuid @unique
  profession    String
  bio           String?
  rating_avg    Float @default(0)
  total_reviews Int @default(0)
  is_approved   Boolean @default(false)
  created_at    DateTime @default(now()) 
  updated_at    DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id])
  verifiable_documents VerifiableDocument[]
  professional_services_offered ProfessionalServicesOffered[]

  @@map("intrabbler_profiles")
}

model VerifiableDocument {
  id                    Int @id @default(autoincrement())
  intrabbler_profile_id Int
  document_type_id      Int @unique 
  document_url          String         
  status                DocumentStatus @default(Pending)
  rejection_reason      String?        
  submitted_at          DateTime @default(now()) 
  reviewed_at           DateTime?      
  reviewed_by_id        String @db.Uuid
  expires_at            DateTime?      
  verification_channel  VerificationChannel @default(manual)
  didit_session_id      String?
  created_at            DateTime @default(now()) 
  updated_at            DateTime @updatedAt

  intrabbler_profile    IntrabblerProfile @relation(fields: [intrabbler_profile_id], references: [id])
  document_type         DocumentType @relation(fields: [document_type_id], references: [id])
  reviewed_by           User @relation(fields: [reviewed_by_id], references: [id])

  @@map("verifiable_documents")
}

model ServiceCategory {
  id                 Int @id @default(autoincrement())
  name               String
  slug               String @unique
  description        String?
  service_coverage   String? // html content
  is_active          Boolean @default(true)
  icon_url           String?
  cover_photo_url    String?           
  parent_id          Int?
  
  // Nuevos campos para servicios de precio fijo
  has_fixed_price    Boolean @default(false)     // Indica si es servicio de precio fijo
  fixed_price_amount Decimal?                    // Precio fijo en COP (null si has_fixed_price = false)
  price_currency     String @default("COP")     // Moneda del precio fijo
  
  created_at         DateTime @default(now()) 
  updated_at         DateTime @updatedAt           

  parent             ServiceCategory? @relation("SubCategories", fields: [parent_id], references: [id])
  children           ServiceCategory[] @relation("SubCategories")
  category_parameters ServiceCategoryParameter[]
  service_requests   ServiceRequest[]
  professional_services_offered ProfessionalServicesOffered[]

  @@index([name])
  @@index([is_active])
  @@index([parent_id])
  @@index([name, is_active])
  @@index([has_fixed_price])
  @@map("service_categories")
}

model ServiceRequest {
  id                      Int @id @default(autoincrement())
  client_id               String @db.Uuid // debe tener role='client'
  service_category_id     Int                  
  title                   String
  location_address_id     Int?              // Opcional para fixed_price inicialmente
  description             String?
  preferred_date          DateTime?   
  status                  ServiceRequestStatus @default(receiving_offers)
  accepted_counter_offer_id Int? @unique // referencia a la contra oferta aceptada
  initial_budget_id       Int? @unique // referencia al presupuesto inicial del cliente
  is_active               Boolean @default(true)
  
  // Nuevo campo para distinguir tipos de servicio
  request_type            RequestType @default(quotation_based) // quotation_based, fixed_price
  
  // Campos específicos para fixed_price
  amount                  Decimal?         // Monto del servicio de precio fijo
  currency                String @default("COP") // Moneda del servicio
  
  created_at              DateTime @default(now()) 
  updated_at              DateTime @updatedAt

  client                  User @relation(fields: [client_id], references: [id])
  service_category        ServiceCategory @relation(fields: [service_category_id], references: [id])
  location                UserAddress? @relation(fields: [location_address_id], references: [id])
  parameters              ServiceRequestParameterValue[]
  quotations              Quotations[]      // Solo para quotation_based
  counter_offers          CounterOffer[]
  accepted_counter_offer  CounterOffer? @relation("AcceptedCounterOffer", fields: [accepted_counter_offer_id], references: [id])
  initial_budget          InitialBudget? @relation(fields: [initial_budget_id], references: [id])
  appointment             ServiceAppointment? // puede tener entre cero y uno
  images                  ServiceRequestImage[] // imágenes opcionales (máx. 5)
  
  // Nueva relación para fixed_price
  applications            Applications[]    // Solo para fixed_price

  @@index([request_type])
  @@map("service_requests")
}

model ServiceRequestImage {
  id                  Int @id @default(autoincrement())
  service_request_id  Int
  image_url           String // URL de la imagen (S3, Cloudinary, etc.)
  image_order         Int @default(1) // orden de la imagen (1-5)
  alt_text            String? // texto alternativo opcional
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  service_request     ServiceRequest @relation(fields: [service_request_id], references: [id], onDelete: Cascade)

  @@map("service_request_images")
}

model ServiceCategoryParameter {
  id                  Int @id @default(autoincrement())
  name                String
  code                String @unique
  parameter_type      CategoryParameterValueType
  is_required         Boolean @default(false)
  is_active           Boolean @default(true)
  options_json        Json?
  min_value           Float?
  max_value           Float?
  service_category_id Int
  created_at          DateTime @default(now()) 
  updated_at          DateTime @updatedAt

  service_category    ServiceCategory @relation(fields: [service_category_id], references: [id])
  request_parameters  ServiceRequestParameterValue[]

  @@map("category_parameters")
}

model ServiceRequestParameterValue {
  id                    Int @id @default(autoincrement())
  service_request_id    Int
  category_parameter_id Int
  value_number          Float?
  value_text            String?
  value_boolean         Boolean?
  created_at            DateTime @default(now()) 
  updated_at            DateTime @updatedAt

  service_request ServiceRequest @relation(fields: [service_request_id], references: [id])
  category_parameter ServiceCategoryParameter @relation(fields: [category_parameter_id], references: [id])

  @@map("request_parameter_values")
}

model EstimatedPricesQuotations {
  id Int @id @default(autoincrement())
  estimated_unit_quantity Float
  estimated_unit_price Float
  estimated_total Float // unit_quantity * unit_price
  pricing_type PricingType
  additional_costs Float? @default(0) // costos adicionales estimados
  created_at DateTime @default(now()) 
  updated_at DateTime @updatedAt
  quotation Quotations?

  @@map("estimated_prices_quotations")
}

model InitialBudget {
  id Int @id @default(autoincrement())
  budget_unit_quantity Float // cantidad de unidades que el cliente estima necesitar
  budget_unit_price Float // precio por unidad que el cliente está dispuesto a pagar
  budget_total Float // budget_unit_quantity * budget_unit_price
  pricing_type PricingType // por hora, día o trabajo completo
  additional_costs Float? @default(0) // costos adicionales que el cliente puede considerar
  created_at DateTime @default(now()) 
  updated_at DateTime @updatedAt
  service_request ServiceRequest?

  @@map("initial_budgets")
}

model Quotations {
  id Int @id @default(autoincrement())
  message String
  status QuotationStatus @default(pending)
  submitted_at DateTime @default(now())
  responded_at DateTime?
  estimated_distance_km Float?
  availability_type AvailabilityType
  availability_in_days Int? @default(0)
  service_request_id Int
  intrabbler_id String @db.Uuid
  estimated_price_id Int @unique
  created_at DateTime @default(now()) 
  updated_at DateTime @updatedAt

  service_request ServiceRequest @relation(fields: [service_request_id], references: [id])
  intrabbler User @relation(fields: [intrabbler_id], references: [id])
  estimated_price EstimatedPricesQuotations @relation(fields: [estimated_price_id], references: [id])
  counter_offers CounterOffer[]
  service_appointment ServiceAppointment?

  @@map("quotations")
}

model CounterOffer {
  id                     Int @id @default(autoincrement())
  service_request_id     Int
  quotation_id           Int
  parent_counter_offer_id Int? // referencia a la contra oferta padre (si es una contra-contra oferta)
  offered_by_id          String @db.Uuid // quien hizo la contra oferta (cliente o aliado)
  amount                 Float // monto propuesto en la contra oferta
  message                String? // mensaje opcional
  status                 CounterOfferStatus @default(pending)
  submitted_at           DateTime @default(now())
  responded_at           DateTime?
  created_at             DateTime @default(now())
  updated_at             DateTime @updatedAt

  service_request        ServiceRequest @relation(fields: [service_request_id], references: [id])
  quotation              Quotations @relation(fields: [quotation_id], references: [id])
  parent_counter_offer   CounterOffer? @relation("CounterOfferChain", fields: [parent_counter_offer_id], references: [id])
  child_counter_offers   CounterOffer[] @relation("CounterOfferChain")
  offered_by             User @relation(fields: [offered_by_id], references: [id])
  accepted_service_request ServiceRequest? @relation("AcceptedCounterOffer")

  @@map("counter_offers")
}

model ServiceAppointment {
  id                    Int @id @default(autoincrement())
  appointment_date      DateTime
  duration_minutes      Int @default(60)
  status                AppointmentStatus @default(pending)
  modality              Modality @default(in_person)
  cancelation_reason    String?
  cancelation_at        DateTime?
  client_id             String @db.Uuid
  intrabbler_id         String @db.Uuid
  service_request_id    Int @unique
  location_address_id   Int
  
  // Campos opcionales dependiendo del tipo de servicio
  quotation_id          Int? @unique      // FK a Quotations (para quotation_based) - unique for 1:1
  application_id        Int? @unique      // FK a Applications (para fixed_price) - unique for 1:1
  
  created_at            DateTime @default(now()) 
  updated_at            DateTime @updatedAt

  client User @relation("ClientAppointments", fields: [client_id], references: [id])
  intrabbler User @relation("ProfessionalAppointments", fields: [intrabbler_id], references: [id])
  quotation Quotations? @relation(fields: [quotation_id], references: [id])
  application Applications? @relation(fields: [application_id], references: [id])
  location_address UserAddress @relation("LocationAddress", fields: [location_address_id], references: [id])
  service_request ServiceRequest @relation(fields: [service_request_id], references: [id])
  reviews Review[]
  transactions WalletTransaction[]
  commission_record CommissionRecord?
  incidents AppointmentIncident[]

  @@map("service_appointments")
}

model AppointmentIncident {
  id              Int @id @default(autoincrement())
  appointment_id  Int
  reported_by     String @db.Uuid // ID del usuario que reporta (intrabbler o cliente)
  incident_type   IncidentType
  description     String
  severity        IncidentSeverity
  resolved        Boolean @default(false)
  resolved_at     DateTime?
  resolved_by     String? @db.Uuid // ID del usuario que resolvió (admin, intrabbler, etc.)
  resolution_notes String?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  appointment     ServiceAppointment @relation(fields: [appointment_id], references: [id])
  reporter        User @relation("IncidentReporter", fields: [reported_by], references: [id])
  resolver        User? @relation("IncidentResolver", fields: [resolved_by], references: [id])

  @@map("appointment_incidents")
}

model Review {
  id Int @id @default(autoincrement())
  service_appointment_id Int
  reviewer_id String @db.Uuid
  rating Float
  comment String?
  created_at DateTime @default(now()) 
  updated_at DateTime @updatedAt

  service_appointment ServiceAppointment @relation(fields: [service_appointment_id], references: [id])
  reviewer User @relation("ReviewerReviews", fields: [reviewer_id], references: [id]) // client or intrabbler

  @@map("reviews")
}

model Wallet {
  id            Int @id @default(autoincrement())
  user_id       String @db.Uuid @unique
  balance       Float @default(0)
  currency      String @default("COP")
  created_at    DateTime @default(now()) 
  updated_at    DateTime @updatedAt

  user          User @relation(fields: [user_id], references: [id])
  transactions  WalletTransaction[]

  @@map("wallets")
}

model PaymentMethod {
  id                    Int @id @default(autoincrement())
  name                  String
  code                  String @unique
  description           String?
  is_active             Boolean @default(true)
  url_icon              String?
  is_visible_in_app     Boolean @default(true)
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  transactions          WalletTransaction[]
  commission_payments   CommissionPayment[]

  @@map("payment_methods")
}

model WalletTransaction {
  id                  Int @id @default(autoincrement())
  amount              Float @default(0)
  type                WalletTransactionType
  description         String?
  status              TransactionStatus @default(pending)
  transaction_id      String @unique
  wallet_id           Int
  payment_method_id   Int? // NULL si es pago por comision, ya que el metodo de pago se registra en la comision
  related_service_appointment_id Int?
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  wallet              Wallet @relation(fields: [wallet_id], references: [id])
  payment_method      PaymentMethod? @relation(fields: [payment_method_id], references: [id], onDelete: Cascade)
  related_service_appointment ServiceAppointment? @relation(fields: [related_service_appointment_id], references: [id], onDelete: Cascade)
  commission_payment  CommissionPayment?
  wompi_payment       WompiPayment?

  @@map("wallet_transactions")
}


model ProfessionalServicesOffered {
  id Int @id @default(autoincrement())
  intrabbler_profile_id Int
  service_category_id Int
  created_at          DateTime @default(now()) 

  intrabbler_profile    IntrabblerProfile @relation(fields: [intrabbler_profile_id], references: [id])
  service_category      ServiceCategory @relation(fields: [service_category_id], references: [id])

@@map("professional_services_offered")
}

model CommissionRecord {
  id                        Int @id @default(autoincrement())
  service_appointment_id    Int @unique
  
  // Configuración de comisión (snapshot al momento de crear la cita)
  commission_percentage_due Float    // % que se debe cobrar (snapshot)
  commission_amount_due     Float    // monto que se debe cobrar
  
  // Tracking de pagos realizados
  commission_percentage_paid Float @default(0)  // % ya cobrado
  commission_amount_paid     Float @default(0)  // monto ya cobrado
  
  // Estados y flags
  is_paid_full             Boolean @default(false)  // ¿está completamente pagado?
  payment_status           CommissionPaymentStatus @default(pending)
  
  // Audit trail
  due_date                 DateTime?   // cuándo vence la comisión
  first_payment_at         DateTime?   // primer pago parcial
  fully_paid_at            DateTime?   // cuándo se completó el pago
  
  // Metadatos
  notes                    String?     // notas sobre la comisión
  created_at               DateTime @default(now())
  updated_at               DateTime @updatedAt
  
  // Relaciones
  service_appointment      ServiceAppointment @relation(fields: [service_appointment_id], references: [id])
  commission_payments      CommissionPayment[]  // pagos parciales
  
  @@map("commission_records")
}

model CommissionPayment {
  id                    Int @id @default(autoincrement())
  commission_record_id  Int
  
  amount_paid           Float
  percentage_paid       Float    // qué % del total representa este pago
  payment_method_id     Int  // efectivo, transferencia, etc.
  
  // Referencias a transacciones
  wallet_transaction_id Int @unique     // relación con WalletTransaction (siempre requerida)
  
  // Audit trail flexible
  processed_by_id       String? @db.Uuid  // NULL si es automático
  processed_automatically Boolean @default(false)  // flag para saber si fue automático
  processing_system     String?  // ej: "cron_job", "webhook", "manual_admin"
  
  processed_at          DateTime @default(now())
  notes                 String?
  
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt
  
  // Relaciones  
  commission_record     CommissionRecord @relation(fields: [commission_record_id], references: [id])
  wallet_transaction    WalletTransaction @relation(fields: [wallet_transaction_id], references: [id])
  processed_by          User? @relation("CommissionProcessor", fields: [processed_by_id], references: [id])
  payment_method        PaymentMethod @relation(fields: [payment_method_id], references: [id])
  
  @@map("commission_payments")
}

// Nuevo modelo: Applications para servicios de precio fijo
model Applications {
  id                    Int @id @default(autoincrement())
  service_request_id    Int                          // FK a ServiceRequest
  intrabbler_id         String @db.Uuid             // FK a User (aliado)
  message               String?                      // Mensaje opcional del aliado
  status                ApplicationStatus @default(pending) // pending, selected, rejected
  applied_at            DateTime @default(now())     // Cuando aplicó
  selected_at           DateTime?                    // Cuando fue seleccionado
  created_at            DateTime @default(now()) 
  updated_at            DateTime @updatedAt

  service_request       ServiceRequest @relation(fields: [service_request_id], references: [id])
  intrabbler           User @relation(fields: [intrabbler_id], references: [id])
  service_appointment  ServiceAppointment?          // Una vez seleccionado y pagado

  @@unique([service_request_id, intrabbler_id])     // Un aliado solo puede aplicar una vez por servicio
  @@map("applications")
}

// Nuevo modelo para horarios de disponibilidad
model AllyAvailability {
  id                Int @id @default(autoincrement())
  intrabbler_id     String @db.Uuid                 // FK a User (aliado)
  day_of_week       Int                             // 0=Domingo, 1=Lunes, ..., 6=Sábado
  start_time        String                          // Formato "HH:mm" (ej: "09:00")
  end_time          String                          // Formato "HH:mm" (ej: "18:00")
  is_active         Boolean @default(true)          // Para deshabilitar horarios temporalmente
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  intrabbler        User @relation(fields: [intrabbler_id], references: [id])
  
  @@unique([intrabbler_id, day_of_week, start_time, end_time]) // Evitar duplicados
  @@map("ally_availability")
}

// Nuevo modelo para configuración de comisiones
model CommissionSettings {
  id                    Int @id @default(autoincrement())
  service_type          CommissionServiceType        // quotation_based, fixed_price
  commission_percentage Decimal                      // Porcentaje de comisión (ej: 10.5 = 10.5%)
  min_commission_amount Decimal?                     // Comisión mínima en COP
  max_commission_amount Decimal?                     // Comisión máxima en COP
  is_active            Boolean @default(true)        // Para deshabilitar configuraciones
  created_at           DateTime @default(now())
  updated_at           DateTime @updatedAt

  @@map("commission_settings")
}

// Modelo para almacenar tokens de dispositivos FCM/Expo
model DeviceToken {
  id            Int       @id @default(autoincrement())
  user_id       String    @db.Uuid
  fcm_token     String    @unique
  expo_token    String?
  platform      String    @default("unknown")
  device_id     String?
  app_version   String?
  is_active     Boolean   @default(true)
  last_used_at  DateTime?
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt

  // Relación con el usuario
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  // Índices
  @@index([user_id])
  @@index([is_active])
  @@map("device_tokens")
}

// Modelo para almacenar notificaciones fallidas y gestionar reintentos
model FailedNotification {
  id                Int       @id @default(autoincrement())
  user_id           String    @db.Uuid
  notification_type String    // 'nueva_oportunidad', 'cotizacion_aceptada', etc.
  event             String    // evento original del WebSocket
  payload           Json      // payload completo de la notificación
  attempts          Int       @default(0)
  max_attempts      Int       @default(3)
  last_error        String?   // último error encontrado
  next_retry_at     DateTime  // cuándo intentar de nuevo
  priority          String    @default("normal") // 'low', 'normal', 'high', 'critical'
  is_resolved       Boolean   @default(false) // si finalmente se envió exitosamente
  resolved_at       DateTime? // cuándo se resolvió
  resolved_method   String?   // 'websocket', 'push', 'sms', 'email'
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt

  // Relación con el usuario
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  // Índices para optimizar queries
  @@index([user_id])
  @@index([is_resolved])
  @@index([next_retry_at])
  @@index([notification_type])
  @@index([priority])
  @@map("failed_notifications")
}

// -------------------------------------
// Payment Gateway Models (Wompi)
// -------------------------------------

// Tabla para guardar información de pagos de Wompi
model WompiPayment {
  id                      Int       @id @default(autoincrement())
  wallet_transaction_id   Int       @unique

  // IDs de Wompi
  wompi_transaction_id    String    @unique  // ID único de Wompi
  wompi_reference         String    @unique  // Referencia del comercio (nuestro transaction_id)

  // Detalles del pago
  payment_method_type     String?   // CARD, NEQUI, PSE, BANCOLOMBIA_TRANSFER, etc.
  async_payment_url       String?   // URL asíncrona para PSE y BANCOLOMBIA_TRANSFER

  // Metadata
  customer_email          String?
  customer_phone          String?

  // Fechas importantes
  created_at_wompi        DateTime?
  finalized_at_wompi      DateTime?

  // Estado interno
  raw_response            Json?     // Respuesta completa de Wompi
  created_at              DateTime  @default(now())
  updated_at              DateTime  @updatedAt

  wallet_transaction      WalletTransaction @relation(fields: [wallet_transaction_id], references: [id])

  @@index([wompi_transaction_id])
  @@index([wompi_reference])
  @@map("wompi_payments")
}

// Tabla para logs de webhooks
model WompiWebhookLog {
  id                      Int       @id @default(autoincrement())
  event_type              String    // transaction.updated, payout.completed, etc.
  wompi_event_id          String?   // ID del evento de Wompi (si existe)
  signature               String
  signature_valid         Boolean
  payload                 Json
  processed               Boolean   @default(false)
  processed_at            DateTime?
  error_message           String?
  retry_count             Int       @default(0)
  created_at              DateTime  @default(now())

  @@index([event_type])
  @@index([processed])
  @@index([created_at])
  @@map("wompi_webhook_logs")
}